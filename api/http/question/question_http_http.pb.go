// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.2
// - protoc             v4.25.0
// source: http/question/question_http.proto

package question

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationQuestionAddUserAnswer = "/http.question.Question/AddUserAnswer"
const OperationQuestionCreatQuestion = "/http.question.Question/CreatQuestion"
const OperationQuestionGetResultById = "/http.question.Question/GetResultById"
const OperationQuestionListQuestionByPage = "/http.question.Question/ListQuestionByPage"
const OperationQuestionModifyQuestion = "/http.question.Question/ModifyQuestion"

type QuestionHTTPServer interface {
	// AddUserAnswer 懒得再开一个文件，所以把 UserAnswer 的接口也直接放这里了
	AddUserAnswer(context.Context, *AddUserAnswerRequest) (*AddUserAnswerReply, error)
	CreatQuestion(context.Context, *CreatQuestionRequest) (*CreatQuestionReply, error)
	GetResultById(context.Context, *GetResultByIdRequest) (*GetResultByIdReply, error)
	ListQuestionByPage(context.Context, *ListQuestionByPageRequest) (*ListQuestionByPageReply, error)
	ModifyQuestion(context.Context, *ModifyQuestionRequest) (*ModifyQuestionReply, error)
}

func RegisterQuestionHTTPServer(s *http.Server, srv QuestionHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/question/creatquestion", _Question_CreatQuestion0_HTTP_Handler(srv))
	r.POST("/v1/question/modifyquestion", _Question_ModifyQuestion0_HTTP_Handler(srv))
	r.POST("/v1/question/listquestion", _Question_ListQuestionByPage0_HTTP_Handler(srv))
	r.POST("/v1/question/adduseranswer", _Question_AddUserAnswer0_HTTP_Handler(srv))
	r.POST("/v1/question/getresultbyid", _Question_GetResultById0_HTTP_Handler(srv))
}

func _Question_CreatQuestion0_HTTP_Handler(srv QuestionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreatQuestionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationQuestionCreatQuestion)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreatQuestion(ctx, req.(*CreatQuestionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreatQuestionReply)
		return ctx.Result(200, reply)
	}
}

func _Question_ModifyQuestion0_HTTP_Handler(srv QuestionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ModifyQuestionRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationQuestionModifyQuestion)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ModifyQuestion(ctx, req.(*ModifyQuestionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ModifyQuestionReply)
		return ctx.Result(200, reply)
	}
}

func _Question_ListQuestionByPage0_HTTP_Handler(srv QuestionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListQuestionByPageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationQuestionListQuestionByPage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListQuestionByPage(ctx, req.(*ListQuestionByPageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListQuestionByPageReply)
		return ctx.Result(200, reply)
	}
}

func _Question_AddUserAnswer0_HTTP_Handler(srv QuestionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddUserAnswerRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationQuestionAddUserAnswer)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddUserAnswer(ctx, req.(*AddUserAnswerRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AddUserAnswerReply)
		return ctx.Result(200, reply)
	}
}

func _Question_GetResultById0_HTTP_Handler(srv QuestionHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetResultByIdRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationQuestionGetResultById)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetResultById(ctx, req.(*GetResultByIdRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetResultByIdReply)
		return ctx.Result(200, reply)
	}
}

type QuestionHTTPClient interface {
	AddUserAnswer(ctx context.Context, req *AddUserAnswerRequest, opts ...http.CallOption) (rsp *AddUserAnswerReply, err error)
	CreatQuestion(ctx context.Context, req *CreatQuestionRequest, opts ...http.CallOption) (rsp *CreatQuestionReply, err error)
	GetResultById(ctx context.Context, req *GetResultByIdRequest, opts ...http.CallOption) (rsp *GetResultByIdReply, err error)
	ListQuestionByPage(ctx context.Context, req *ListQuestionByPageRequest, opts ...http.CallOption) (rsp *ListQuestionByPageReply, err error)
	ModifyQuestion(ctx context.Context, req *ModifyQuestionRequest, opts ...http.CallOption) (rsp *ModifyQuestionReply, err error)
}

type QuestionHTTPClientImpl struct {
	cc *http.Client
}

func NewQuestionHTTPClient(client *http.Client) QuestionHTTPClient {
	return &QuestionHTTPClientImpl{client}
}

func (c *QuestionHTTPClientImpl) AddUserAnswer(ctx context.Context, in *AddUserAnswerRequest, opts ...http.CallOption) (*AddUserAnswerReply, error) {
	var out AddUserAnswerReply
	pattern := "/v1/question/adduseranswer"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationQuestionAddUserAnswer))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *QuestionHTTPClientImpl) CreatQuestion(ctx context.Context, in *CreatQuestionRequest, opts ...http.CallOption) (*CreatQuestionReply, error) {
	var out CreatQuestionReply
	pattern := "/v1/question/creatquestion"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationQuestionCreatQuestion))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *QuestionHTTPClientImpl) GetResultById(ctx context.Context, in *GetResultByIdRequest, opts ...http.CallOption) (*GetResultByIdReply, error) {
	var out GetResultByIdReply
	pattern := "/v1/question/getresultbyid"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationQuestionGetResultById))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *QuestionHTTPClientImpl) ListQuestionByPage(ctx context.Context, in *ListQuestionByPageRequest, opts ...http.CallOption) (*ListQuestionByPageReply, error) {
	var out ListQuestionByPageReply
	pattern := "/v1/question/listquestion"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationQuestionListQuestionByPage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *QuestionHTTPClientImpl) ModifyQuestion(ctx context.Context, in *ModifyQuestionRequest, opts ...http.CallOption) (*ModifyQuestionReply, error) {
	var out ModifyQuestionReply
	pattern := "/v1/question/modifyquestion"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationQuestionModifyQuestion))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
