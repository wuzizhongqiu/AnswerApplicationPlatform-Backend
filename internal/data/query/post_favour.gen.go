// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"wuzigoweb/internal/data/model"
)

func newPostFavour(db *gorm.DB, opts ...gen.DOOption) postFavour {
	_postFavour := postFavour{}

	_postFavour.postFavourDo.UseDB(db, opts...)
	_postFavour.postFavourDo.UseModel(&model.PostFavour{})

	tableName := _postFavour.postFavourDo.TableName()
	_postFavour.ALL = field.NewAsterisk(tableName)
	_postFavour.ID = field.NewInt64(tableName, "id")
	_postFavour.CreateTime = field.NewTime(tableName, "create_time")
	_postFavour.UpdateTime = field.NewTime(tableName, "update_time")
	_postFavour.PostID = field.NewInt64(tableName, "post_id")
	_postFavour.UserID = field.NewInt64(tableName, "user_id")

	_postFavour.fillFieldMap()

	return _postFavour
}

// postFavour 帖子收藏
type postFavour struct {
	postFavourDo postFavourDo

	ALL        field.Asterisk
	ID         field.Int64 // id
	CreateTime field.Time  // 创建时间
	UpdateTime field.Time  // 更新时间
	PostID     field.Int64 // 帖子 id
	UserID     field.Int64 // 创建用户 id

	fieldMap map[string]field.Expr
}

func (p postFavour) Table(newTableName string) *postFavour {
	p.postFavourDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p postFavour) As(alias string) *postFavour {
	p.postFavourDo.DO = *(p.postFavourDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *postFavour) updateTableName(table string) *postFavour {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.CreateTime = field.NewTime(table, "create_time")
	p.UpdateTime = field.NewTime(table, "update_time")
	p.PostID = field.NewInt64(table, "post_id")
	p.UserID = field.NewInt64(table, "user_id")

	p.fillFieldMap()

	return p
}

func (p *postFavour) WithContext(ctx context.Context) IPostFavourDo {
	return p.postFavourDo.WithContext(ctx)
}

func (p postFavour) TableName() string { return p.postFavourDo.TableName() }

func (p postFavour) Alias() string { return p.postFavourDo.Alias() }

func (p postFavour) Columns(cols ...field.Expr) gen.Columns { return p.postFavourDo.Columns(cols...) }

func (p *postFavour) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *postFavour) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 5)
	p.fieldMap["id"] = p.ID
	p.fieldMap["create_time"] = p.CreateTime
	p.fieldMap["update_time"] = p.UpdateTime
	p.fieldMap["post_id"] = p.PostID
	p.fieldMap["user_id"] = p.UserID
}

func (p postFavour) clone(db *gorm.DB) postFavour {
	p.postFavourDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p postFavour) replaceDB(db *gorm.DB) postFavour {
	p.postFavourDo.ReplaceDB(db)
	return p
}

type postFavourDo struct{ gen.DO }

type IPostFavourDo interface {
	gen.SubQuery
	Debug() IPostFavourDo
	WithContext(ctx context.Context) IPostFavourDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPostFavourDo
	WriteDB() IPostFavourDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPostFavourDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPostFavourDo
	Not(conds ...gen.Condition) IPostFavourDo
	Or(conds ...gen.Condition) IPostFavourDo
	Select(conds ...field.Expr) IPostFavourDo
	Where(conds ...gen.Condition) IPostFavourDo
	Order(conds ...field.Expr) IPostFavourDo
	Distinct(cols ...field.Expr) IPostFavourDo
	Omit(cols ...field.Expr) IPostFavourDo
	Join(table schema.Tabler, on ...field.Expr) IPostFavourDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPostFavourDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPostFavourDo
	Group(cols ...field.Expr) IPostFavourDo
	Having(conds ...gen.Condition) IPostFavourDo
	Limit(limit int) IPostFavourDo
	Offset(offset int) IPostFavourDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPostFavourDo
	Unscoped() IPostFavourDo
	Create(values ...*model.PostFavour) error
	CreateInBatches(values []*model.PostFavour, batchSize int) error
	Save(values ...*model.PostFavour) error
	First() (*model.PostFavour, error)
	Take() (*model.PostFavour, error)
	Last() (*model.PostFavour, error)
	Find() ([]*model.PostFavour, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PostFavour, err error)
	FindInBatches(result *[]*model.PostFavour, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PostFavour) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPostFavourDo
	Assign(attrs ...field.AssignExpr) IPostFavourDo
	Joins(fields ...field.RelationField) IPostFavourDo
	Preload(fields ...field.RelationField) IPostFavourDo
	FirstOrInit() (*model.PostFavour, error)
	FirstOrCreate() (*model.PostFavour, error)
	FindByPage(offset int, limit int) (result []*model.PostFavour, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPostFavourDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p postFavourDo) Debug() IPostFavourDo {
	return p.withDO(p.DO.Debug())
}

func (p postFavourDo) WithContext(ctx context.Context) IPostFavourDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p postFavourDo) ReadDB() IPostFavourDo {
	return p.Clauses(dbresolver.Read)
}

func (p postFavourDo) WriteDB() IPostFavourDo {
	return p.Clauses(dbresolver.Write)
}

func (p postFavourDo) Session(config *gorm.Session) IPostFavourDo {
	return p.withDO(p.DO.Session(config))
}

func (p postFavourDo) Clauses(conds ...clause.Expression) IPostFavourDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p postFavourDo) Returning(value interface{}, columns ...string) IPostFavourDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p postFavourDo) Not(conds ...gen.Condition) IPostFavourDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p postFavourDo) Or(conds ...gen.Condition) IPostFavourDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p postFavourDo) Select(conds ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p postFavourDo) Where(conds ...gen.Condition) IPostFavourDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p postFavourDo) Order(conds ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p postFavourDo) Distinct(cols ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p postFavourDo) Omit(cols ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p postFavourDo) Join(table schema.Tabler, on ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p postFavourDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p postFavourDo) RightJoin(table schema.Tabler, on ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p postFavourDo) Group(cols ...field.Expr) IPostFavourDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p postFavourDo) Having(conds ...gen.Condition) IPostFavourDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p postFavourDo) Limit(limit int) IPostFavourDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p postFavourDo) Offset(offset int) IPostFavourDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p postFavourDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPostFavourDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p postFavourDo) Unscoped() IPostFavourDo {
	return p.withDO(p.DO.Unscoped())
}

func (p postFavourDo) Create(values ...*model.PostFavour) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p postFavourDo) CreateInBatches(values []*model.PostFavour, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p postFavourDo) Save(values ...*model.PostFavour) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p postFavourDo) First() (*model.PostFavour, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PostFavour), nil
	}
}

func (p postFavourDo) Take() (*model.PostFavour, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PostFavour), nil
	}
}

func (p postFavourDo) Last() (*model.PostFavour, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PostFavour), nil
	}
}

func (p postFavourDo) Find() ([]*model.PostFavour, error) {
	result, err := p.DO.Find()
	return result.([]*model.PostFavour), err
}

func (p postFavourDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PostFavour, err error) {
	buf := make([]*model.PostFavour, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p postFavourDo) FindInBatches(result *[]*model.PostFavour, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p postFavourDo) Attrs(attrs ...field.AssignExpr) IPostFavourDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p postFavourDo) Assign(attrs ...field.AssignExpr) IPostFavourDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p postFavourDo) Joins(fields ...field.RelationField) IPostFavourDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p postFavourDo) Preload(fields ...field.RelationField) IPostFavourDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p postFavourDo) FirstOrInit() (*model.PostFavour, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PostFavour), nil
	}
}

func (p postFavourDo) FirstOrCreate() (*model.PostFavour, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PostFavour), nil
	}
}

func (p postFavourDo) FindByPage(offset int, limit int) (result []*model.PostFavour, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p postFavourDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p postFavourDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p postFavourDo) Delete(models ...*model.PostFavour) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *postFavourDo) withDO(do gen.Dao) *postFavourDo {
	p.DO = *do.(*gen.DO)
	return p
}
